==========================================
树基础
==========================================

什么是树
==========================================
定义: n（n>=0)个节点构成的有限集合。子树是不想交的，出个根节点，每个节点有且只有一个父节点。

几个概念

- 节点的度： 节点的子树个数。
- 树的度： 树的所有节点中最大的度。
- 节点的层次： 规定根节点在1层，其他任意节点的层数是其父节点+1。
- 树的深度： 树中所有节点中最大层次是这棵树的深度。
- 父节点： 有子树的节点是其子树的根节点的父节点。
- 子节点： 如果a节点是b节点的父节点，则成b是a节点的子节点。
- 兄弟节点： 具有同一个父亲节点的各节点是兄弟节点。

什么是二叉树
==========================================
度为2的树，可以为空。

- 一个二叉树，第i层的最大节点树为 pow(2,i-1)。
- 深度为k的二叉树有最大节点树为pow(2,k)-1。
- 对任何非空二叉树T,若n0表示叶子节点个数，n1表示一个子节点的个数，n2表示2个子节点的个数，则n0=n2+1。 

证明如下： 

.. code-block:: text 

    n表示总边树 = 总结点树 -1 = n0 +n1 +n2 -1 
    总结点 = 0 *n0 + 1 * n1 + 2 *n2 
    n0 +n1 +n2 -1 = n1 + 2 * n2 
    n0=n2+1 。

抽象数据结构描述

.. code-block:: text 

    类型名称： 二叉树
    数据对象集： 一个有穷的节点集合
    操作集： 
        Boolean IsEmpty(BinTree bt): 判断树是否为空。
        void Traversal (BinTree bt): 遍历树，按某种顺序访问每个节点。
        BinTree CreateBinTree(): 创建一个二叉树。

        void PreOrderTraversal(BinTree bt): 先序： 根 左子树 右子树
        void InOrderTraversal(BinTree bt): 中序： 左子树 根 右子树
        void PosOrderTraversal(BinTree bt): 后序： 左子树 右子树 根
        void LevelOrderTraversal(BinTree bt): 先序： 从上到下，从左到右。先第一层遍历完毕，在第二层。每次从左到右。



二叉树顺序存储实现
==========================================

完全二叉树： 按照从上到下，从左到右存储。 

特点： 

- 非根节点的父节点需要为 [i/2] 
- 节点i的左孩子为2i 如果2i<=n（节点个数） 则表示没有左孩子节点。
- 节点i的右孩子为2i+1 如果2i+1<=n（节点个数） 则表示没有右孩子节点。

对于一般二叉树，也是可以采用这种方式的， 但是空间浪费是比较严重的。 


.. literalinclude:: ../code/bitree_list_base.c
   :encoding: utf-8
   :language: c
   :linenos:

二叉树顺序存储实现
==========================================

.. literalinclude:: ../code/bitree_link_base.h
   :encoding: utf-8
   :language: c
   :linenos:

.. literalinclude:: ../code/bitree_link_base.c
   :encoding: utf-8
   :language: c
   :linenos: